<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Speed</title>
    <style>
        body { margin: 0; touch-action: none; overflow: hidden; background: #000; }
        canvas { width: 100vw; height: 100vh; display: block; user-select: none; }
    </style>
</head>
<body>
    <script type="x-shader/x-fragment" id="fragmentShader">#version 300 es
    precision highp float;
    out vec4 O;
    uniform float time;
    uniform vec2 resolution;
    #define FC gl_FragCoord.xy
    #define R resolution
    #define T time
    #define hue(a) (.6+.6*cos(6.3*(a)+vec3(0,83,21)))

    float rnd(float a) {
        vec2 p=fract(a*vec2(12.9898,78.233));   
        p+=dot(p,p*345.);
        return fract(p.x*p.y);
    }

    vec3 pattern(vec2 uv) {
        vec3 col=vec3(0);
        for (float i=.0; i++<20.;) {
            float a=rnd(i);
            vec2 n=vec2(a,fract(a*34.56)), p=sin(n*(T+7.)+T*.5);
            float d=dot(uv-p,uv-p);
            col+=.00125/d*hue(dot(uv,uv)+i*.125+T);
        }
        return col;
    }

    void main(void) {
        vec2 uv=(FC-.5*R)/min(R.x,R.y);
        vec3 col=vec3(0);
        float s=2.4,
        a=atan(uv.x,uv.y),
        b=length(uv);
        uv=vec2(a*5./6.28318,.05/tan(b)+T);
        uv=fract(uv)-.5;
        col+=pattern(uv*s);
        O=vec4(col,1);
    }
    </script>

    <script>
        // The JavaScript: Manages the WebGL Pipeline
        window.onload = init;

        function init() {
            let renderer, canvas;
            const dpr = Math.max(1, .5 * window.devicePixelRatio);
            
            canvas = document.createElement("canvas");
            document.body.appendChild(canvas);

            const resize = () => {
                canvas.width = window.innerWidth * dpr;
                canvas.height = window.innerHeight * dpr;
                if (renderer) renderer.updateScale(dpr);
            };

            const source = document.getElementById("fragmentShader").textContent;
            renderer = new Renderer(canvas, dpr);
            renderer.setup(source);
            renderer.init();
            
            resize();
            window.onresize = resize;

            const loop = (now) => {
                renderer.render(now);
                requestAnimationFrame(loop);
            };
            loop(0);
        }

        class Renderer {
            #vertexSrc = "#version 300 es\nprecision highp float;\nin vec4 position;\nvoid main(){gl_Position=position;}";
            #vertices = [-1, 1, -1, -1, 1, 1, 1, -1];

            constructor(canvas, scale) {
                this.canvas = canvas;
                this.scale = scale;
                this.gl = canvas.getContext("webgl2");
            }

            updateScale(scale) {
                this.scale = scale;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            compile(shader, source) {
                const gl = this.gl;
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(gl.getShaderInfoLog(shader));
                }
            }

            setup(fragmentSource) {
                const gl = this.gl;
                this.vs = gl.createShader(gl.VERTEX_SHADER);
                this.fs = gl.createShader(gl.FRAGMENT_SHADER);
                this.compile(this.vs, this.#vertexSrc);
                this.compile(this.fs, fragmentSource);
                this.program = gl.createProgram();
                gl.attachShader(this.program, this.vs);
                gl.attachShader(this.program, this.fs);
                gl.linkProgram(this.program);
            }

            init() {
                const { gl, program } = this;
                this.buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#vertices), gl.STATIC_DRAW);
                const position = gl.getAttribLocation(program, "position");
                gl.enableVertexAttribArray(position);
                gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
                program.resolution = gl.getUniformLocation(program, "resolution");
                program.time = gl.getUniformLocation(program, "time");
            }

            render(now = 0) {
                const { gl, program, buffer, canvas } = this;
                if (!program) return;
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(program);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.uniform2f(program.resolution, canvas.width, canvas.height);
                gl.uniform1f(program.time, now * 0.001);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }
    </script>
</body>
</html>
